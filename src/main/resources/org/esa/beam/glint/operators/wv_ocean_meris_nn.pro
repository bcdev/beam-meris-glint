pro help_wv_ocean_meris_nn
a=   ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     This is a neural net generated by bck                   ;;;;;;;"]
a=[a,";;;;                Version: Feb. 2000                           ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     Date: Wed Nov 30 17:15:33 2005                          ;;;;;;;"]
a=[a,";;;;     Used train data:    wvo_meris.trn                       ;;;;;;;"]
a=[a,";;;;     Used test data:     wvo_meris.tst                       ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     It can be used like any other idl-function:             ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     Result = wv_ocean_meris_nn(Input  $                     ;;;;;;;"]
a=[a,";;;;                         ,index=index                $       ;;;;;;;"]
a=[a,";;;;                         ,return_partial_differential=rpd  $ ;;;;;;;"]
a=[a,";;;;                         ,/no_warn )                         ;;;;;;;"]
a=[a,";;;;            or                                               ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     Result = wv_ocean_meris_nn(/help)                       ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     Input must be array of the dimension (*,  5) or (  5)   ;;;;;;;"]
a=[a,";;;;     Result is an array of the dimension  (*,  1) or (  1)   ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     Names of Input and Output (from train data)             ;;;;;;;"]
a=[a,";;;;     Input   1:  wind (min =  3.75e-02  max =  1.84e+01)     ;;;;;;;"]
a=[a,";;;;     Input   2:   azi (min = -6.33e-01  max =  6.31e-01)     ;;;;;;;"]
a=[a,";;;;     Input   3:  view (min =  7.73e-01  max =  1.00e+00)     ;;;;;;;"]
a=[a,";;;;     Input   4:   sun (min =  1.60e-01  max =  9.26e-01)     ;;;;;;;"]
a=[a,";;;;     Input   5:    rr (min = -6.98e-01  max = -1.25e-01)     ;;;;;;;"]
a=[a,";;;;     Output  1:   wvo (min =  1.22e-03  max =  7.62e+00)     ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     If Input dimension is bad defined then this help        ;;;;;;;"]
a=[a,";;;;     message is printed and the result is the string:        ;;;;;;;"]
a=[a,";;;;     `something is wrong with your input dimension`          ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     If Input exceeds the range defined at training          ;;;;;;;"]
a=[a,";;;;     a warning message is printed. This message is           ;;;;;;;"]
a=[a,";;;;     supressed if the keyword no_warning is set.             ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     The index keyword returns a longword vector             ;;;;;;;"]
a=[a,";;;;     containing the subscripts of the input elements         ;;;;;;;"]
a=[a,";;;;     within the range defined at training.                   ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;     If the return_partial_differential keyword is set       ;;;;;;;"]
a=[a,";;;;     the matrix of partial differentials d_out/d_in          ;;;;;;;"]
a=[a,";;;;     at the given input is returned. Here input must         ;;;;;;;"]
a=[a,";;;;     contain only one point in the input space.              ;;;;;;;"]
a=[a,";;;;     Up to now this works only for linear scaled in-         ;;;;;;;"]
a=[a,";;;;     and output.                                             ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;           Rene Preusker                                     ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;           rene.preusker@wew.fu-berlin.de                    ;;;;;;;"]
a=[a,";;;;                                                             ;;;;;;;"]
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
a=[a,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"]
print,a,format="(a72)"
end
 
 
 
 
function sigmoide, x , temperatur
in= (((temperatur*x)>(-80.))<80.)*(-1.)
out=1./(1.+exp(in))
return,out
end
 
 
function wv_ocean_meris_nn,input, no_warning=no_warning,help=help,index=index  $
         ,max_train_in=max_train_in,min_train_in=min_train_in $
         ,return_partial_differential=return_partial_differential
if keyword_set(help) or (n_params() ne 1) then begin
	y=0
	help_wv_ocean_meris_nn
	goto,ende
endif
x=input
help,input,output=help_x
y="something is wrong with your input dimension:"
dimi =        5
dimo =        1
dimh =        4
bias_h =       1.00000
bias_i =       1.00000
sizex=size(input)
if sizex(0) eq 1 then begin
	x=transpose(x)
	if sizex(1) ne dimi then begin
		help_wv_ocean_meris_nn
		print,y
		print,help_x
		goto,ende
		endif
	in=fltarr(1,dimi+1)
	zw=fltarr(1,dimh+1)
	endif
if sizex(0) eq 2 then begin
	if sizex(2) ne dimi then begin
		help_wv_ocean_meris_nn
		print,y
		print,help_x
		goto,ende
		endif
	in=fltarr(sizex(1),dimi+1)
	zw=fltarr(sizex(1),dimh+1)
	endif
if (sizex(0) ne 1) and (sizex(0) ne 2) then begin
	help_wv_ocean_meris_nn
	print,y
	print,help_x
	goto,ende
	endif
 
 
 
max_train_in = fltarr(dimi)
min_train_in = fltarr(dimi)
max_train_in(       0)= 1.836580849e+01
max_train_in(       1)= 6.312184930e-01
max_train_in(       2)= 1.000000000e+00
max_train_in(       3)= 9.264965653e-01
max_train_in(       4)=-1.251673251e-01
min_train_in(       0)= 3.750000149e-02
min_train_in(       1)=-6.332216859e-01
min_train_in(       2)= 7.728424072e-01
min_train_in(       3)= 1.602766067e-01
min_train_in(       4)=-6.978100538e-01
index=where((x(*,0) le max_train_in(0)) $
        and (x(*,0) ge min_train_in(0)))
if index(0) ne -1 then begin 
	for i=1, dimi-1 do begin
 	     dum=where((x(index,i) le max_train_in(i))       $
 	           and (x(index,i) ge min_train_in(i)))
 	     if (dum(0) ne -1) then index=index(dum) else index=[-1]
    endfor
endif 
 
  
if not (keyword_set(no_warning)) then begin
  names_in     = strarr(dimi)
  names_in(       0)='wind'
  names_in(       1)='azi'
  names_in(       2)='view'
  names_in(       3)='sun'
  names_in(       4)='rr'
  wo_dum1      = replicate("  ",dimi)
  wo_dum2      = replicate("  ",dimi)
  max_in = fltarr(dimi)
  min_in = fltarr(dimi)
  for i=0,dimi-1 do max_in(i)=max(x(*,i)) 
  for i=0,dimi-1 do min_in(i)=min(x(*,i)) 
  max_gt= (max_in gt max_train_in)
  if total (max_gt) gt 0 then begin
     print,""
     print,"WARNING: Maximum of Input is greater than Maximum of Train Input: "
     format='(a33,5(a9,2x,"|",1x))'
     print,"Name of Input         | ", names_in, format=format
     format='(a33,5("-----------","+","-"))'
     print,"----------------------+-", format=format
     format='(a33,5(e9.2,2x,"|",1x))'
     print,"Maximum of Traininput | ", max_train_in, format=format
     print,"Maximum of Input      | ", max_in, format=format
     wo_dum1(where(max_gt))="/\"
     wo_dum2(where(max_gt))="||"
     format='(a33,5(6x,a2,3x," ",1x))'
     print,"                        ",wo_dum1, format=format
     print,"                        ",wo_dum2, format=format
     wo_dum1(where(max_gt))="  "
     wo_dum2(where(max_gt))="  "
     print,""
    endif
  min_lt= (min_in lt min_train_in)
  if total(min_lt) gt 0 then begin
     print,""
     print,"WARNING: Minimum of Input is less than Minimum of Train Input:"
     format='(a33,5(a9,2x,"|",1x))'
     print,"Name of Input         | ", names_in, format=format
     format='(a33,5("-----------","+","-"))'
     print,"----------------------+-", format=format
     format='(a33,5(e9.2,2x,"|",1x))'
     print,"Minimum of Traininput | ", min_train_in, format=format
     print,"Minimum of Input      | ", min_in, format=format
     wo_dum1(where(min_lt))="/\"
     wo_dum2(where(min_lt))="||"
     format='(a33,5(6x,a2,3x," ",1x))'
     print,"                        ",wo_dum1, format=format
     print,"                        ",wo_dum2, format=format
     print,""
    endif
endif
 
 
x(*,       0)=( 5.000000075e-02)+( 4.910436645e-02)*(x(*,       0)-( 3.750000149e-02))
x(*,       1)=( 5.000000075e-02)+( 7.117774487e-01)*(x(*,       1)-(-6.332216859e-01))
x(*,       2)=( 5.000000075e-02)+( 3.962007046e+00)*(x(*,       2)-( 7.728424072e-01))
x(*,       3)=( 5.000000075e-02)+( 1.174597383e+00)*(x(*,       3)-( 1.602766067e-01))
x(*,       4)=( 5.000000075e-02)+( 1.571660519e+00)*(x(*,       4)-(-6.978100538e-01))
 
in(*,0:dimi-1)=x(*,0:dimi-1)
in(*,dimi)=in(*,dimi)*0.+bias_i
zw(*,dimh)=zw(*,dimh)*0.+bias_h
inv=fltarr(dimi+1,dimh)
outv=fltarr(dimh+1,dimo)
inv(       0,       0)= 2.168307781e+00
inv(       0,       1)=-2.397819042e+00
inv(       0,       2)= 4.222361565e+00
inv(       0,       3)=-1.875129104e+00
inv(       1,       0)= 4.474287331e-01
inv(       1,       1)= 9.003549576e+00
inv(       1,       2)=-1.332859135e+01
inv(       1,       3)=-6.878470421e+00
inv(       2,       0)=-1.252183533e+01
inv(       2,       1)=-5.159142494e+00
inv(       2,       2)=-9.892419815e+00
inv(       2,       3)= 1.781698465e-01
inv(       3,       0)= 1.452473998e+00
inv(       3,       1)= 1.298282146e+01
inv(       3,       2)=-1.090335655e+01
inv(       3,       3)=-1.055383396e+01
inv(       4,       0)= 2.110732079e+01
inv(       4,       1)= 7.626058459e-01
inv(       4,       2)=-2.262421036e+01
inv(       4,       3)= 3.177322960e+01
inv(       5,       0)= 2.810472727e+00
inv(       5,       1)=-2.807153893e+01
inv(       5,       2)= 1.808895683e+01
inv(       5,       3)=-1.733368874e+01
outv(       0,       0)=-1.358780956e+01
outv(       1,       0)= 3.323241425e+01
outv(       2,       0)= 7.895359039e+00
outv(       3,       0)=-5.218487263e+00
outv(       4,       0)= 7.207462788e+00
temperatur =  1.000000000e+00
zw(*,0:dimh-1)=sigmoide(in#inv,temperatur/float(dimi))
y=sigmoide(zw#outv,temperatur/float(dimh))

if keyword_set(return_partial_differential) then begin
	if n_elements(x) ne dimi then begin
		print,"Matrix of partial differentials will be calculated"
		print,"on one point in input space only. Thus input"
		print,"must have the dimension (1,"+string(dimi)+") or ("+string(dimi)+")!"
		return,"Something is wrong with your input!"
		endif
	zws=zw*(1.-zw)*temperatur/float(dimi)
	ys=y*(1.-y)*temperatur/float(dimh)
	e_in=fltarr(dimi,dimi)
	e_in[       0,       0]= 4.910436645e-02
	e_in[       1,       1]= 7.117774487e-01
	e_in[       2,       2]= 3.962007046e+00
	e_in[       3,       3]= 1.174597383e+00
	e_in[       4,       4]= 1.571660519e+00
	e_z=fltarr(dimh,dimh)
	for i=0,dimh-1 do e_z[i,i]=zws[i]
	e_y=fltarr(dimo,dimo)
	for i=0,dimo-1 do e_y[i,i]=ys[i]
	e_out=fltarr(dimo,dimo)
	e_out[       0,       0]=1./ 1.049362272e-01
	return,(((((e_in#inv[0:dimi-1,*])#e_z)#outv[0:dimh-1,*])#e_y)#e_out)
	endif
y(*,       0)=(y(*,       0)-( 1.000000015e-01))/( 1.049362272e-01)+( 1.219108701e-03)
if sizex(0) eq 1 then begin
	y=transpose(y)
	endif
ende:
return,y
end
